	if (sc) { // These statuses do not reflect any damage (off the target)
		if (sc->data[SC_WHITEIMPRISON] || sc->data[SC_DARKCROW] ||
			(sc->data[SC_KYOMU] && (!ssc || !ssc->data[SC_SHIELDSPELL_DEF]))) // Nullify reflecting ability except for Shield Spell - Def
				return 0;
	}

	if (ssc) {
		if (ssc->data[SC_HELLS_PLANT])
			return 0;
	}

	if (flag & BF_SHORT) {//Bounces back part of the damage.
		if ( (skill_get_inf2(skill_id, INF2_ISTRAP) || !status_reflect) && sd && sd->bonus.short_weapon_damage_return ) {
			rdamage += damage * sd->bonus.short_weapon_damage_return / 100;
			rdamage = i64max(rdamage, 1);
		} else if( status_reflect && sc && sc->count ) {
			if( sc->data[SC_REFLECTSHIELD] ) {
				struct status_change_entry *sce_d;
				struct block_list *d_bl = NULL;

				if( (sce_d = sc->data[SC_DEVOTION]) && (d_bl = map_id2bl(sce_d->val1)) &&
					((d_bl->type == BL_MER && ((TBL_MER*)d_bl)->master && ((TBL_MER*)d_bl)->master->bl.id == bl->id) ||
					(d_bl->type == BL_PC && ((TBL_PC*)d_bl)->devotion[sce_d->val2] == bl->id)) )
				{ //Don't reflect non-skill attack if has SC_REFLECTSHIELD from Devotion bonus inheritance
					if( (!skill_id && battle_config.devotion_rdamage_skill_only && sc->data[SC_REFLECTSHIELD]->val4) ||
						!check_distance_bl(bl,d_bl,sce_d->val3) )
						return 0;
				}
			}
			if( sc->data[SC_REFLECTDAMAGE] && !skill_get_inf2(skill_id, INF2_ISTRAP)) {
				if( rnd()%100 <= sc->data[SC_REFLECTDAMAGE]->val1*10 + 30 ){
					max_damage = (int64)max_damage * status_get_lv(bl) / 100;
					rdamage = (*dmg) * sc->data[SC_REFLECTDAMAGE]->val2 / 100;
					if( --(sc->data[SC_REFLECTDAMAGE]->val3) < 1)
						status_change_end(bl,SC_REFLECTDAMAGE,INVALID_TIMER);
				}
			} else {
				if ( sc->data[SC_REFLECTSHIELD] && skill_id != WS_CARTTERMINATION ) {
					// Don't reflect non-skill attack if has SC_REFLECTSHIELD from Devotion bonus inheritance
					if (!skill_id && battle_config.devotion_rdamage_skill_only && sc->data[SC_REFLECTSHIELD]->val4)
						rdamage = 0;
					else {
						rdamage += damage * sc->data[SC_REFLECTSHIELD]->val2 / 100;
						rdamage = i64max(rdamage, 1);
					}
				}

				if (sc->data[SC_DEATHBOUND] && skill_id != WS_CARTTERMINATION && skill_id != GN_HELLS_PLANT_ATK && !status_bl_has_mode(src,MD_STATUSIMMUNE)) {
					if (distance_bl(src,bl) <= 0 || !map_check_dir(map_calc_dir(bl,src->x,src->y), unit_getdir(bl))) {
						int64 rd1 = 0;

						rd1 = min(damage,status_get_max_hp(bl)) * sc->data[SC_DEATHBOUND]->val2 / 100; // Amplify damage.
						*dmg = rd1 * 30 / 100; // Received damage = 30% of amplified damage.
						clif_skill_damage(src, bl, gettick(), status_get_amotion(src), 0, -30000, 1, RK_DEATHBOUND, sc->data[SC_DEATHBOUND]->val1, DMG_SINGLE);
						skill_blown(bl, src, skill_get_blewcount(RK_DEATHBOUND, 1), unit_getdir(src), BLOWN_NONE);
						status_change_end(bl, SC_DEATHBOUND, INVALID_TIMER);
						rdamage += rd1 * 70 / 100; // Target receives 70% of the amplified damage. [Rytech]
					}
				}

				if( sc->data[SC_SHIELDSPELL_DEF] && sc->data[SC_SHIELDSPELL_DEF]->val1 == 2 && !status_bl_has_mode(src,MD_STATUSIMMUNE) ){
						rdamage += damage * sc->data[SC_SHIELDSPELL_DEF]->val2 / 100;
						rdamage = i64max(rdamage, 1);
				}
			}
		}
	} else {
		if (!status_reflect && sd && sd->bonus.long_weapon_damage_return) {
			rdamage += damage * sd->bonus.long_weapon_damage_return / 100;
			rdamage = i64max(rdamage, 1);
		}
	}

	if (rdamage > 0) {
		map_session_data* ssd = BL_CAST(BL_PC, src);
		if (ssd && ssd->bonus.reduce_damage_return != 0) {
			rdamage -= rdamage * ssd->bonus.reduce_damage_return / 100;
			rdamage = i64max(rdamage, 1);
		}
	}



































else if( attack_type == BF_WEAPON && tsc->data[SC_REFLECTDAMAGE] ) // Don't reflect your own damage (Grand Cross)
				map_foreachinshootrange(battle_damage_area,target,skill_get_splash(LG_REFLECTDAMAGE,1),BL_CHAR,tick,target,wd->amotion,sstatus->dmotion,rdamage,wd->flag);
			else if( attack_type == BF_WEAPON || attack_type == BF_MISC) {
				rdelay = clif_damage(src, (!d_bl) ? src : d_bl, tick, wd->amotion, sstatus->dmotion, rdamage, 1, DMG_ENDURE, 0, false);
				if( tsd )
					battle_drain(tsd, src, rdamage, rdamage, sstatus->race, sstatus->class_);
				// It appears that official servers give skill reflect damage a longer delay
				battle_delay_damage(tick, wd->amotion, target, (!d_bl) ? src : d_bl, 0, CR_REFLECTSHIELD, 0, rdamage, ATK_DEF, rdelay ,true, false);
				skill_additional_effect(target, (!d_bl) ? src : d_bl, CR_REFLECTSHIELD, 1, BF_WEAPON|BF_SHORT|BF_NORMAL, ATK_DEF, tick);
			}
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	/**
	* Extended Vending system [Lilith]
	**/
	{ "extended_vending",					&battle_config.extended_vending,				1,		0,		1,				},
	{ "show_broadcas_info",					&battle_config.show_broadcas_info,				1,		0,		1,				},
	{ "show_item_vending",					&battle_config.show_item_vending,				1,		0,		1,				},
	{ "ex_vending_info",					&battle_config.ex_vending_info,					1,		0,		1,				},
	{ "ex_vending_report",					&battle_config.ex_vending_report,				1,		0,		1,				}, // [Easycore]
	{ "item_zeny",							&battle_config.item_zeny,						0,		0,		MAX_ITEMID,		},
	{ "item_cash",							&battle_config.item_cash,						0,		0,		MAX_ITEMID,		},

	/**
	* Extended Vending system [Lilith]
	**/
	int extended_vending;
	int show_broadcas_info;
	int show_item_vending;
	int ex_vending_info;
	int ex_vending_report;
	int item_zeny;
	int item_cash;
	
	unsigned short vend_loot;		// Extended Vending system [Lilith]
	
	// Vending shouldn't open if vend_loot is 0 and extended vending is enabled [Easycore]
	ShowWarning("vend loot = %d\n", sd->vend_loot);
	if (battle_config.extended_vending && sd->vend_loot == 0) {
		sd->state.prevend = 0;
		return;
	}
	
		z += ((double)vsd->vending[j].value * (double)amount);	
		/**
		* Extended Vending system [Lilith]
		**/
		if (battle_config.extended_vending) {
			if (vsd->vend_loot == battle_config.item_zeny || !vsd->vend_loot) {
				if (z > (double)sd->status.zeny || z < 0. || z >(double)MAX_ZENY)
				{
					//clif_buyvending(sd, idx, amount, 1); // you don't have enough zeny
					return;
				}
				if (z + (double)vsd->status.zeny > (double)MAX_ZENY && !battle_config.vending_over_max)
				{
					clif_buyvending(sd, idx, vsd->vending[j].amount, 4); // too much zeny = overflow
					return;
				}
			}
			else if (vsd->vend_loot == battle_config.item_cash) {
				if (z > sd->cashPoints || z < 0. || z >(double)MAX_ZENY) {
					clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], msg_txt(sd, 1590), false, SELF);
					return;
				}
			}
			else {
				int k, loot_count = 0, vsd_w = 0;
				for (k = 0; k < MAX_INVENTORY; k++) {
					if (sd->inventory.u.items_inventory[k].bound) {
						clif_displaymessage(sd->fd, "Cannot buy with Bound Items.");
						return;
					}
					if (sd->inventory.u.items_inventory[k].nameid == vsd->vend_loot)
						loot_count += sd->inventory.u.items_inventory[k].amount;
				}
 
				if (z > loot_count || z < 0)
				{
					clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], msg_txt(sd, 1591), false, SELF);
					return;
				}
				if (pc_inventoryblank(vsd) <= 0)
				{
					clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], msg_txt(sd, 1592), false, SELF);
					return;
				}
				vsd_w += itemdb_weight(vsd->vend_loot) * (int)z;
				if (vsd_w + vsd->weight > vsd->max_weight)
				{
					clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], msg_txt(sd, 1593), false, SELF);
					return;
				}
			}

	/**
	* Extended Vending system [Lilith]
	**/
	if (battle_config.extended_vending) {
		if (vsd->vend_loot == battle_config.item_zeny || !vsd->vend_loot) {
			pc_payzeny(sd, (int)z, LOG_TYPE_VENDING, vsd);
			achievement_update_objective(sd, AG_SPEND_ZENY, 1, (int)z);
			z = vending_calc_tax(sd, z);
			pc_getzeny(vsd, (int)z, LOG_TYPE_VENDING, sd);
		}
		else if (vsd->vend_loot == battle_config.item_cash) {
			pc_paycash(sd, (int)z, 0, LOG_TYPE_VENDING);
			pc_getcash(vsd, (int)z, 0, LOG_TYPE_VENDING);
		}
		else {
			for (i = 0; i < MAX_INVENTORY; i++)
				if (sd->inventory.u.items_inventory[i].nameid == vsd->vend_loot)
				{
					struct item *item;
					item = &sd->inventory.u.items_inventory[i];
					pc_additem(vsd, item, (int)z, LOG_TYPE_VENDING);
				}
			pc_delitem(sd, pc_search_inventory(sd, vsd->vend_loot), (int)z, 0, 6, LOG_TYPE_VENDING);
		}
	}
	else {
		pc_payzeny(sd, (int)z, LOG_TYPE_VENDING, vsd);
		achievement_update_objective(sd, AG_SPEND_ZENY, 1, (int)z);
		z = vending_calc_tax(sd, z);
		pc_getzeny(vsd, (int)z, LOG_TYPE_VENDING, sd);
	}
	int mailprofit = 0;

			if (battle_config.ex_vending_info) {// Extended Vending system [Lilith]
				double rev = ((double)vsd->vending[vend_list[i]].value * (double)amount);
				if (vsd->vend_loot == ITEMID_ZENY)
					sprintf(temp, msg_txt(sd, 1597), sd->status.name, item_name, amount, (int)(rev -= rev * (battle_config.vending_tax / 10000.)),"Zeny");
				else
					sprintf(temp, msg_txt(sd, 1597), sd->status.name, item_name, amount, (int)rev, itemdb_ename(vsd->vend_loot)); //No Tax for Items/Cash [Easycore]
			} else
				sprintf(temp, msg_txt(sd, 265), sd->status.name);
			clif_displaymessage(vsd->fd, temp);
		}
		if (battle_config.ex_vending_info) { // Extended Vending system [Lilith]
			char temp[256];
			double frev = ((double)vsd->vending[vend_list[i]].value * (double)amount);
			sprintf(temp, msg_txt(sd,1598), sd->status.name, (int)frev, vsd->vend_loot?itemdb_ename(vsd->vend_loot):"Zeny");
			clif_displaymessage(vsd->fd, temp);
		}
		if (battle_config.ex_vending_report && pc_readglobalreg(vsd, add_str("NOVREPORT")) == 0 ) { // Vending Report MailBox [Easycore]
			const char *sender, *title, *body;
			struct mail_message msg;
			char message[1000];
			mailprofit += vsd->vending[vend_list[i]].value *amount;
			memset(&msg, 0, sizeof(struct mail_message));
			msg.dest_id = vsd->status.char_id;
			sender = "Server";
			safestrncpy(msg.send_name, sender, NAME_LENGTH);
			title = "Vending Report";
			safestrncpy(msg.title, title, MAIL_TITLE_LENGTH);
			if (i == 0)
				sprintf(message, "[%s] has bought in your store: \r\n", sd->status.name);
			#if PACKETVER >= 20150513 // Old mail box is too shorter [Easycore]
			if (i >= 0 && strlen(message)<180)
				sprintf(message + strlen(message), "   - %s x %d ea\r\n", item_name, amount);
			else if (strlen(message)<200)
				sprintf(message + strlen(message), "......and more\r\n");
			#endif
			if (i == count-1) {
				if (vsd->vend_loot == ITEMID_ZENY)
					sprintf(message + strlen(message), "Total profit: %s x %d", "Zeny" ,(mailprofit -= mailprofit * (int)(battle_config.vending_tax / 10000.)));
				else
					sprintf(message + strlen(message), "Total profit: %s x %d",itemdb_ename(vsd->vend_loot) ,mailprofit); //No Tax for Items/Cash [Easycore]
			}
			body = message;
			safestrncpy(msg.body, body, MAIL_BODY_LENGTH);
			msg.status = MAIL_NEW;
			msg.type = MAIL_INBOX_NORMAL;
			msg.timestamp = time(NULL);
			if (i==count-1)
				intif_Mail_send(0, &msg);

		}

/**
* Extended Vending system [Lilith]
**/
int clif_vend(struct map_session_data *sd, int skill_lv) {

	nullpo_ret( sd );

	int fd = sd->fd;

	if( !session_isActive( fd ) ){
		return 0;
	}

	WFIFOHEAD( fd, sizeof( struct PACKET_ZC_MAKINGARROW_LIST ) + (ARRAYLENGTH(item_vend)+2) * sizeof( struct PACKET_ZC_MAKINGARROW_LIST_sub ) );
	struct PACKET_ZC_MAKINGARROW_LIST *p = (struct PACKET_ZC_MAKINGARROW_LIST *)WFIFOP( fd, 0 );
	p->packetType = HEADER_ZC_MAKINGARROW_LIST;

	int i, count = 0;
	if (battle_config.item_zeny && itemdb_exists(battle_config.item_zeny) ) {
		p->items[count].itemId = client_nameid(battle_config.item_zeny);
		count++;
	}

	if (battle_config.item_cash && itemdb_exists(battle_config.item_cash) ) {
		p->items[count].itemId = client_nameid(battle_config.item_cash);
		count++;
	}

	for ( i = 0; i < ARRAYLENGTH(item_vend); i++) {
		struct item_data* item;
		t_itemid nameid = item_vend[i].itemid;

		if( nameid != battle_config.item_zeny && nameid != battle_config.item_cash && (item = itemdb_exists(nameid)) ) {
			p->items[count].itemId = client_nameid(nameid);
			count++;
		}
	}

	p->packetLength = sizeof( struct PACKET_ZC_MAKINGARROW_LIST ) + count * sizeof( struct PACKET_ZC_MAKINGARROW_LIST_sub );
	WFIFOSET( fd, p->packetLength );

	if( count > 0 ){
		sd->menuskill_id = MC_VENDING;
		sd->menuskill_val = skill_lv;
	}
	else {
		clif_skill_fail(sd, MC_VENDING, USESKILL_FAIL_LEVEL, 0);
		return 0;
	}
	return 1;
}
