	/**
	* Extended Vending system [Lilith]
	**/
	{ "extended_vending",					&battle_config.extended_vending,				1,		0,		1,				},
	{ "show_broadcas_info",					&battle_config.show_broadcas_info,				1,		0,		1,				},
	{ "show_item_vending",					&battle_config.show_item_vending,				1,		0,		1,				},
	{ "ex_vending_info",					&battle_config.ex_vending_info,					1,		0,		1,				},
	{ "ex_vending_report",					&battle_config.ex_vending_report,				1,		0,		1,				}, // [Easycore]
	{ "item_zeny",							&battle_config.item_zeny,						0,		0,		MAX_ITEMID,		},
	{ "item_cash",							&battle_config.item_cash,						0,		0,		MAX_ITEMID,		},

	/**
	* Extended Vending system [Lilith]
	**/
	int extended_vending;
	int show_broadcas_info;
	int show_item_vending;
	int ex_vending_info;
	int ex_vending_report;
	int item_zeny;
	int item_cash;
	
	unsigned short vend_loot;		// Extended Vending system [Lilith]
	
	// Vending shouldn't open if vend_loot is 0 and extended vending is enabled [Easycore]
	ShowWarning("vend loot = %d\n", sd->vend_loot);
	if (battle_config.extended_vending && sd->vend_loot == 0) {
		sd->state.prevend = 0;
		return;
	}
	
		z += ((double)vsd->vending[j].value * (double)amount);	
		/**
		* Extended Vending system [Lilith]
		**/
		if (battle_config.extended_vending) {
			if (vsd->vend_loot == battle_config.item_zeny || !vsd->vend_loot) {
				if (z > (double)sd->status.zeny || z < 0. || z >(double)MAX_ZENY)
				{
					//clif_buyvending(sd, idx, amount, 1); // you don't have enough zeny
					return;
				}
				if (z + (double)vsd->status.zeny > (double)MAX_ZENY && !battle_config.vending_over_max)
				{
					clif_buyvending(sd, idx, vsd->vending[j].amount, 4); // too much zeny = overflow
					return;
				}
			}
			else if (vsd->vend_loot == battle_config.item_cash) {
				if (z > sd->cashPoints || z < 0. || z >(double)MAX_ZENY) {
					clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], msg_txt(sd, 1590), false, SELF);
					return;
				}
			}
			else {
				int k, loot_count = 0, vsd_w = 0;
				for (k = 0; k < MAX_INVENTORY; k++) {
					if (sd->inventory.u.items_inventory[k].bound) {
						clif_displaymessage(sd->fd, "Cannot buy with Bound Items.");
						return;
					}
					if (sd->inventory.u.items_inventory[k].nameid == vsd->vend_loot)
						loot_count += sd->inventory.u.items_inventory[k].amount;
				}
 
				if (z > loot_count || z < 0)
				{
					clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], msg_txt(sd, 1591), false, SELF);
					return;
				}
				if (pc_inventoryblank(vsd) <= 0)
				{
					clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], msg_txt(sd, 1592), false, SELF);
					return;
				}
				vsd_w += itemdb_weight(vsd->vend_loot) * (int)z;
				if (vsd_w + vsd->weight > vsd->max_weight)
				{
					clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], msg_txt(sd, 1593), false, SELF);
					return;
				}
			}

	/**
	* Extended Vending system [Lilith]
	**/
	if (battle_config.extended_vending) {
		if (vsd->vend_loot == ITEMID_ZENY || !vsd->vend_loot) {
			pc_payzeny(sd, (int)z, LOG_TYPE_VENDING, vsd);
			achievement_update_objective(sd, AG_SPEND_ZENY, 1, (int)z);
			z = vending_calc_tax(sd, z);
			pc_getzeny(vsd, (int)z, LOG_TYPE_VENDING, sd);
		}
		else if (vsd->vend_loot == ITEMID_CASH) {
			pc_paycash(sd, (int)z, 0, LOG_TYPE_VENDING);
			pc_getcash(vsd, (int)z, 0, LOG_TYPE_VENDING);
		}
		else {
			for (i = 0; i < MAX_INVENTORY; i++)
				if (sd->inventory.u.items_inventory[i].nameid == vsd->vend_loot)
				{
					struct item *item;
					item = &sd->inventory.u.items_inventory[i];
					pc_additem(vsd, item, (int)z, LOG_TYPE_VENDING);
				}
			pc_delitem(sd, pc_search_inventory(sd, vsd->vend_loot), (int)z, 0, 6, LOG_TYPE_VENDING);
		}
	}
	else {
		pc_payzeny(sd, (int)z, LOG_TYPE_VENDING, vsd);
		achievement_update_objective(sd, AG_SPEND_ZENY, 1, (int)z);
		z = vending_calc_tax(sd, z);
		pc_getzeny(vsd, (int)z, LOG_TYPE_VENDING, sd);
	}
	int mailprofit = 0;

			if (battle_config.ex_vending_info) {// Extended Vending system [Lilith]
				double rev = ((double)vsd->vending[vend_list[i]].value * (double)amount);
				if (vsd->vend_loot == ITEMID_ZENY)
					sprintf(temp, msg_txt(sd, 1597), sd->status.name, item_name, amount, (int)(rev -= rev * (battle_config.vending_tax / 10000.)),"Zeny");
				else
					sprintf(temp, msg_txt(sd, 1597), sd->status.name, item_name, amount, (int)rev, itemdb_jname(vsd->vend_loot)); //No Tax for Items/Cash [Easycore]
			} else
				sprintf(temp, msg_txt(sd, 265), sd->status.name);
			clif_displaymessage(vsd->fd, temp);
		}
		if (battle_config.ex_vending_info) { // Extended Vending system [Lilith]
			char temp[256];
			double frev = ((double)vsd->vending[vend_list[i]].value * (double)amount);
			sprintf(temp, msg_txt(sd,1598), sd->status.name, (int)frev, vsd->vend_loot?itemdb_jname(vsd->vend_loot):"Zeny");
			clif_displaymessage(vsd->fd, temp);
		}
		if (battle_config.ex_vending_report && pc_readglobalreg(vsd, add_str("NOVREPORT")) == 0 ) { // Vending Report MailBox [Easycore]
			const char *sender, *title, *body;
			struct mail_message msg;
			char message[1000];
			mailprofit += vsd->vending[vend_list[i]].value *amount;
			memset(&msg, 0, sizeof(struct mail_message));
			msg.dest_id = vsd->status.char_id;
			sender = "Server";
			safestrncpy(msg.send_name, sender, NAME_LENGTH);
			title = "Vending Report";
			safestrncpy(msg.title, title, MAIL_TITLE_LENGTH);
			if (i == 0)
				sprintf(message, "[%s] has bought in your store: \r\n", sd->status.name);
			#if PACKETVER >= 20150513 // Old mail box is too shorter [Easycore]
			if (i >= 0 && strlen(message)<180)
				sprintf(message + strlen(message), "   - %s x %d ea\r\n", item_name, amount);
			else if (strlen(message)<200)
				sprintf(message + strlen(message), "......and more\r\n");
			#endif
			if (i == count-1) {
				if (vsd->vend_loot == ITEMID_ZENY)
					sprintf(message + strlen(message), "Total profit: %s x %d", "Zeny" ,(mailprofit -= mailprofit * (int)(battle_config.vending_tax / 10000.)));
				else
					sprintf(message + strlen(message), "Total profit: %s x %d",itemdb_jname(vsd->vend_loot) ,mailprofit); //No Tax for Items/Cash [Easycore]
			}
			body = message;
			safestrncpy(msg.body, body, MAIL_BODY_LENGTH);
			msg.status = MAIL_NEW;
			msg.type = MAIL_INBOX_NORMAL;
			msg.timestamp = time(NULL);
			if (i==count-1)
				intif_Mail_send(0, &msg);
